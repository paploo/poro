= Overview

The name "Poro" is derived from "plain ol' Ruby object".  Poro is a simple and
lightweight persistence engine.  Unlike most persistence engines, which require
your persistent objects to be subclasses of a base model class, Poro aims to
extend plain ol' Ruby objects to be stored in any persist way you choose
(e.g. SQL, MongoDB, Memcache), and even mix and match different stores between
objects.

Additionally, Poro takes a hands-off philosophy by default, only minimally
disturbing an object it persists.  Of course, there is a mixin available to add
model functionality to your object if you like, but how and when you do this
is up to you.

While the packages available for managing individual kinds of repositories focus
on a large breadth of functionality, Poro aims to give the simplest, lightest
weight, common interface possible for these storage methods.  Given the disparity
in functionality available between different persistence stores
(e.g. SLQ, key/value, documents), additional needs of the store are accomplished
by working with the individual adapter package APIs themselves rather than
through whatever inferior homogenized API Poro may try to provide.

= Installation

Basic usage only requires the installation of the gem:
    gem install poro
However to utilize any meaningful persistence data store, the underlying gems
for the desired persistence contexts are needed.  The documentation of the
desired Context class' documentation should inform you of any necessary gems,
though a useful error is thrown if you are missing a needed gem, so it is
probably easier to just try.

If you wish to run the gem's unit tests, you should also install <tt>rspec</tt>.

It is also worthwhile checking rake for meaningful tasks, using:
    rake -T

= Architecture

A ContextManager instance is the starting point for using Poro.  The application
may be configured to use any ContextManager, the managing instance of which is
set as the default for easy application-wide access.  The ContextManager's
purpose for existence is to build Context instances for each class.

Contexts allow for easy set-up and customization of how objects are stored and
retrieved.  Contexts can be thought of as delegate objects that handle these
tasks, separating their functionality from that of the objects they handle.

Lastly, there is a basic module (Persist) which can be included into a model
for quick addition of the basic interface useful for a a Poro managed object.
This does a minimal amount of work, and doesn't need to be included, however it
is normally most beneficial to use this to simplify management.

= Getting Started

The following sample code sets up a basic context manager for the application,
using an in-memory only testing store (which is just a hash):

    require 'poro'
    
    Poro::Context.factory = Poro::ContextFactories::SingleStore.instantiate(:hash)
    
    class Foo
      include Poro::Persistify
      include Poro::Modelify
    end
    
    f = Foo.new
    puts "f doesn't have an ID yet: #{f.id.inspect}"
    f.save
    puts "f now has an ID: #{f.id.inspect}"
    g = Foo.fetch(f.id)
    puts "g is a fetch of f and has the same ID as f: #{g.id.inspect}"
    f.remove
    puts "f no longer has an ID: #{f.id.inspect}"
    
= Configuration

Each Context has its own configuration parameters, based on how its data store
works.  There are two ways in which to manage this configuration, depending on
the needs of your application.

== Inline

Many users, thanks to some popular Ruby ORMs, are most comfortable with model
class inline configuration.  Poro's philosophy is to be hands off with objects
in your code, however there is a convenience method included into your object
when you mark it for persistence that makes inline configuration of the context
easy:

    class Person
      include Poro::Persistify
      configure_context do |context|
        context.primary_key = :some_attribute
      end
      include Poro::Modelify # if you want model methods.
    end
    
The above configure method is really just a shortcut to the
<tt>configure_for_class</tt> method on Context, which can be called instead.

== External

The problem with inline configuration is that it does not abstract the
persistence engine from the plain ol' ruby objects.  Poro provides a solution
to this layering violation via a configuration block that is supplied during
ContextManager initialization.  This block may return the fully configured
Context instance for each persistified class.

For example, the following generic code has the same result as
<code>Poro::Context.factory = Poro::ContextFactories::SingleStore.instantiate(:hash)</code>,
which uses a specialized factory:

    Poro::Context.factory = Poro::ContextManager.new do |klass|
      Poro::Contexts::HashContext.new(klass)
    end

Of course, one normally would have a more complex block and/or utilize one of
the specialized factories, but this example shows just how simple a factory
nees to be.

Note that all Contexts are cached after creation, so the context configuration
can be mutated by other methods (such as <tt>configure_for_class</tt> on Context),
but developers are encouraged to choose one paradigm for their application and
stick with it.

= Contact

If you have any questions, comments, concerns, patches, or bugs, you can contact
me via the github repository at:

http://github.com/paploo/poro

or directly via e-mail at:

mailto:jeff@paploo.net

= License

The files contained in this repository are released under the commercially and
GPL compatible "New BSD License", given below:

== License Text

    Copyright (c) 2010, Jeffrey C. Reinecke
    All rights reserved.
    
    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are met:
        * Redistributions of source code must retain the above copyright
          notice, this list of conditions and the following disclaimer.
        * Redistributions in binary form must reproduce the above copyright
          notice, this list of conditions and the following disclaimer in the
          documentation and/or other materials provided with the distribution.
        * Neither the name of the copyright holders nor the
          names of its contributors may be used to endorse or promote products
          derived from this software without specific prior written permission.
    
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
    ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    DISCLAIMED. IN NO EVENT SHALL JEFFREY REINECKE BE LIABLE FOR ANY
    DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
    ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

Poro::Util::Inflector is adapted from ActiveSupport, and its source is
redistributed under the MIT license it was originally distributed under.  The
text of this copyright notice is supplied in <tt>poro/util/inflector.rb</tt>.