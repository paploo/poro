= Overview

The name "Poro" is derived from "plain ol' Ruby object".  Poro is a simple and
lightweight persistence engine.  Unlike most persistence engines, which require
your persistent objects to be subclasses of a base model class, Poro aims to
extend plain ol' Ruby objects to be stored in any persist way you choose
(e.g. SQL, MongoDB, Memcache), and even mix and match different stores between
objects.

While the packages available for managing individual kinds of repositories focus
on a large breadth of functionality, Poro aims to give the simplest, lightest
weight, common interface possible for these storage methods.  Given the disparity
in functionality available between different persistence stores
(e.g. SLQ, key/value, documents), additional needs of the store are accomplished
by working with the individual adapter package APIs themselves rather than
through whatever inferior homogenized API Poro may try to provide.

= Installation

Basic usage only requires the installation of the gem:
    gem install poro
However to utilize any meaningful persistence data store, the underlying gems
for the desired persistence contexts are needed.  The documentation of the
desired Context class' documentation should inform you of any necessary gems,
though a useful error is thrown if you are missing a needed gem, so it is
probably easier to just try.

It is also worthwhile checking rake for meaningful tasks, using:
    rake -T

= Architecture

A ContextManager instance is the starting point for using Poro.  The application
may be configured to use any ContextManager, the managing instance of which is
set as the default for easy application-wide access.  The ContextManager's
purpose for existence is to build Context instances for each class.

Contexts allow for easy set-up and customization of how objects are stored and
retrieved.  Contexts can be thought of as delegate objects that handle these
tasks, separating their functionality from that of the objects they handle.

Lastly, there is a basic module (Persist) which can be included into a model
for quick addition of the basic interface useful for a a Poro managed object.
This does a minimal amount of work, and doesn't need to be included, however it
is normally most beneficial to use this to simplify management.

= Getting Started

The following sample code sets up a basic context manager for the application,
using an in-memory only testing store (which is just a hash):

    require 'poro'

    Poro::ContextManager.build_application_instance("Hashed")

    class Foo
      include Poro::Persistify
    end

    f = Foo.new
    puts "f doesn't have an ID yet: #{f.id.inspect}"
    f.save
    puts "f now has an ID: #{f.id.inspect}"
    g = Foo.fetch(f.id)
    puts "g is a fetch of f and has the same ID as f: #{g.id.inspect}"
    f.remove
    puts "f no longer has an ID: #{f.id.inspect}"
    
= Configuration

Each Context has its own configuration parameters, based on how its data store
works.  There are two ways in which to manage this configuration, depending on
the needs of your application.

== Inline

Many users, thanks to some popular Ruby ORMs, are most comfortable with model
class inline configuration.  Any class that has Poro::Persistify included into
it, has the class method <tt>context</tt>.  This method returns the Context that
manages the object.  Therefore, it is possible to configure the context in the
model via use of this method.  Take this hypothetical example:

    class Person
      include Poro::Persistify
      context.save_columns = [:first_name, :last_name]
    end
    
Keep in mind that each Context has its own configuration methods that are suited
for its backing.  While these seek to be as consistent as possible, it is
important to look at the documentation for that Context to know how to configure
it.

== External

The problem with inline configuration is that it does not abstract the
persistence engine from the plain ol' ruby objects.  Poro provides a solution
to this layering violation via a configuration block that is supplied during
ContextManager initialization.  This block may return the fully configured
Context instance for each persistified class.

For example, the following code is equivalent to
<code>Poro::ContextManager.build_application_instance("Hashed")</code>:

    Poro::ContextManager.instance = Poro::ContextManagers::Cached.new do |klass|
      Poro::Contexts::Hashed.new(klass)
    end

Of course, one normally would have a more complex block, that may utilize a
context building factory of some kind.

Additionally, the <tt>build_instance</tt> method can take a configuration
block that works in a compatible way.

= To Do

The following features are primary features that are being evaluated:

    * ContextFactory:: a class to simplify the configuration of Contexts inside of a configuration file.

= Contact

If you have any questions, comments, concerns, patches, or bugs, you can contact
me via the github repository at:

http://github.com/paploo/poro

or directly via e-mail at:

mailto:jeff@paploo.net

= License

The files contained in this repository are released under the commercially and
GPL compatible "New BSD License", given below:

== License Text

    Copyright (c) 2010, Jeffrey C. Reinecke
    All rights reserved.
    
    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are met:
        * Redistributions of source code must retain the above copyright
          notice, this list of conditions and the following disclaimer.
        * Redistributions in binary form must reproduce the above copyright
          notice, this list of conditions and the following disclaimer in the
          documentation and/or other materials provided with the distribution.
        * Neither the name of the copyright holders nor the
          names of its contributors may be used to endorse or promote products
          derived from this software without specific prior written permission.
    
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
    ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    DISCLAIMED. IN NO EVENT SHALL JEFFREY REINECKE BE LIABLE FOR ANY
    DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
    ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.